/*
Authored by Prof. Jeong-Mo Hong, CSE Dongguk University
for Introduction to Computer Graphics, 2017 Spring
*/

#pragma once

#include <atomic>
//#include <openctm.h>
#include <glm/glm.hpp>
#include <glm/gtx/transform.hpp>

#include "GenericDefinitions.h"
#include "StaticTriangleOperations.h"

#include "DataStructure/LinkedArray.h"
#include "DataStructure/Vector3D.h"
#include "Geometry/Box3D.h"
#include "Geometry/PLANE.h"
#include "Geometry/StaticTriangle.h"
#include "Geometry/TriangularSurface/VertexOperations.h"
#include "Math/Quaternion.h"

class StaticTriangularSurface
{
public:
	Array1D<TV>		vertex_positions_;			// vertex position Array1D
	Array1D<TV>		vertex_positions_temp_;		// temp for smoothing
	Array1D<TV>		vertex_normals_;
	Array1D<TV>		vertex_rgb_;
	Array1D<TV2>	vertex_uv_;	

	Array1D<TV_INT> uv_triangles_;
	Array1D<TV_INT>	triangles_;					// index of 3 vertices

	Box3D<T>		OOBB_;						// object oriented bounding box

	Array1D<TV>		vertex_positions_backup_;	// for undo
	Array1D<TV_INT>	triangles_backup_;			// for undo

	// vertex-triangles connectivity
	Array1D<int> start_ix_adj_tri_of_vertices_;		// 1. count number of adjacent neighbors, 2. store index of neighboring triangles index
	Array1D<int> adj_tri_ix_of_vertices_;				// stores the indices of connected triangles	//TODO: atomic

	Array1D<TV_INT> edge_tri_ix_of_triangles_;		// adjacent triangles of triangles
	Array1D<TV_INT> edge_v_ix_of_triangles_;			// edge vertex generated by subdivision

	LinkedArray<TV> new_vertex_postitions_;		// subdivision vertex buffer
	LinkedArray<TV_INT> new_triangles_;

// 	Array1D<int>		triangles_flag_;	// -1: do not remove this time, -2: deleted
// 	Array1D<int>		vertices_flag_;		// -1: deleted

	VertexOperations	v_ops_;
	StaticTriangleOperations tri_ops_;

	bool use_face_normal_;
	bool print_no_neighbor_edges_;

public:
	StaticTriangularSurface()
		: v_ops_(vertex_positions_, vertex_normals_, start_ix_adj_tri_of_vertices_), tri_ops_(vertex_positions_, triangles_, edge_tri_ix_of_triangles_), use_face_normal_(false), print_no_neighbor_edges_(false)
	{}

public:
	TV		 getEdgeVertex(const int mode, const int& tri_ix, const int& edge_number) const;
	Box3D<T> getAABB() const;

	//void removeEdge(const int& tri_ix0, const int& tri_ix1, const int& edge_ix0, const int& edge_ix1, const int& v_ix0, const int& v_ix1);
	//int  removeShortEdges(const T& min_edge_length, const T kappa);

	int  getNumVertices() const
	{
		return vertex_positions_.num_elements_;
	}

	int  getNumTriangles() const
	{
		return triangles_.num_elements_;
	}

	void getUnsignedIntTriangles(Array1D < Vector3D<unsigned int> > & tri_ix) const;

	void findAdjacentTrianglesOfVertices();
	void determineFaceAveragedVertexNormals();
	void calculateVertexMeanCurvatures(Array1D<TV>& vertex_mean_curvatures) const;
	void findEdgeTrianglesOfTriangles();
	void findBoundaryEdges(LinkedArray<TV2_INT>& boundary_edges);

	void splitLongEdges(const float& lth)
	{
		const float sqr_lth = lth*lth;

		findAdjacentTrianglesOfVertices();
		findEdgeTrianglesOfTriangles();

		//generateEdgeVertices(mode);		// add new edge vertices to new_vertex_postitions_
		new_vertex_postitions_.reset();

		edge_v_ix_of_triangles_.init(triangles_.num_elements_, TV_INT(-1, -1, -1));

		const int ver_ix_offset = vertex_positions_.num_elements_;
		const int num_triangles = triangles_.num_elements_;

		for (int tri_ix = 0; tri_ix < num_triangles; tri_ix++)
		{
			const int *vix = triangles_.values_[tri_ix].values_;
			const int *etri = edge_tri_ix_of_triangles_.values_[tri_ix].values_;

			// Generate edge vertices
			// don't generate edge vertex if edge triangle already has it.
			for (int d = 0; d < 3; d++)
			{
				if (etri[d] != -1 && etri[d] < tri_ix) continue;		// let earlier triangle generate edge vertex

				if (tri_ops_.getSqrEdgeLength(tri_ix, d) < sqr_lth) continue; // split long edges

				const int new_evix = ver_ix_offset + new_vertex_postitions_.num_elements_;		// index of new edge vertex
				new_vertex_postitions_.pushBack() = getEdgeVertex(0, tri_ix, d); // mode = 0, linear
				edge_v_ix_of_triangles_.values_[tri_ix].values_[d] = new_evix;

				if (etri[d] != -1)
					edge_v_ix_of_triangles_.values_[etri[d]].values_[tri_ops_.getEdgeIndex(etri[d], vix[(d + 1) % 3], vix[(d + 2) % 3])] = new_evix;		// update the edge vertex of edge triangle
			}
		}

		//if (mode == 2) smoothVertexPositionsLoop();

		splitTriangles();				// add to new_triangles_ (non-divided triangles are also copied to new_triangles)

		updateVertexAndTriangleLists();	// update vertex_positions_ and triangles_

		findAdjacentTrianglesOfVertices();
		determineFaceAveragedVertexNormals();
	}

	void advanceOneSubdivisionStep(const int mode);
	void applySubdivision(const int mode);	// 0: linear, 1: butterfly, 2: loop
	//void applyPlaneCutSuvdivision(const PLANE& cut_plane);
	void applyLaplacianSmoothing();
	//void generateEdgeVerticesPlaneCut(const PLANE& cut_plane);
	void generateEdgeVertices(const int mode);
	void splitTriangles();
	void updateVertexAndTriangleLists();
	void smoothVertexPositionsLoop();
	void smoothVertexPositionsLaplacian();
	void replaceVertex(const int& tri_ix, const int& old_v, const int& new_v);	// replace old_v with new_v if tri_ix has old_v
	void emptifyTriangle(const int& tri_ix);
	void replaceAdjTriangle(const int& v_ix, const int& old_tri_ix, const int& new_tri_ix);
	void replaceAdjTriangle(const int& v_ix, const int& old_tri_ix1, const int& old_tri_ix2, const int& new_tri_ix);
	void replaceVertexOfAdjTriangles(const int& v_ix, const int& old_v_ix, const int& new_v_ix);
	void replaceEdgeTriangle(const int& tri_ix, const int& old_tri_ix, const int& new_tri_ix);
	//void removeEdgeSharingTriangles(const int &tri_ix0, const int & tri_ix1, const int& edge_ix0, const int& edge_ix1);
	void getTriangle(const int& tri_ix, StaticTriangle& triangle) const;
	void getTriangleUV(const int& tri_ix, TV2 uv_arr[3])const;

	void correctCCWFromVertexNormals();

	void copyRenderingData(Array1D<TV>& positions, Array1D<TV>& normals) const;
	void copyRenderingData(LinkedArray<TV>& positions, LinkedArray<TV>& normals) const;
	void copyRenderingDataShortEdges(LinkedArray<TV>& positions, const T min_edge_length) const;
	void copyRenderingDataShortEdgeTriangles(LinkedArray<TV>& positions, LinkedArray<TV>& normals, const T min_edge_length, const T normal_offset) const;
	void copyRenderingDataHighCurvatureVertices(LinkedArray<TV>& positions, LinkedArray<TV>& normals, const T min_edge_length, const T normal_offset) const;

	// file reading will be moved to other classes
// 	void ReadTRI(const char *filename);			// custom format in which triangle indexes are 0 based unlikely to SMF format.
// 	void ReadSMF(const char *filename);
// 	void ReadOBJ(const char *filename);

	void writeOBJ(const char* filename);
	void writeSTL(const char* filename);
	void writeCTM(const char* filename);
	void writeFile(const char* filename);	// custom '.trisurface' format
	void readFile(const char* filename, const bool& scale_max_to_one = false, const bool& center_to_origin = false);
	void readSTLFile(const char* filename);
	void readObj(const char* filename, const bool& scale_max_to_one = false, const bool& center_to_origin = false);

	void append(const StaticTriangularSurface& surface_to_append);

	void backup();
	void restore();

	bool checkEdgeConnectivity();
	bool checkAllTrianglesContainVIX(const int&v_ix);
	bool isAdjTriContainVertex(const int& v_ix, const int& v_ix_to_check, const int& tri0_ix_ignore, const int& tri1_ix_ignore) const;

	void flipFeatureEdges(const int feature_pt_start);

	// transformation
	void translate(const TV& dev);
	void scale(const T s);
	void scale(const T sx, const T sy, const T sz, const bool centered = true);
	void scaleMinToUnity();
	void scaleMaxToUnity();
	void centerToOrigin();
	void moveMinCornerToOrigin();
	void rotate(const T angle, const TV axis);

	glm::mat4 getModelMatrix(const float& max_edge_length, const bool& move_to_center) const;

	T    getAverageEdgeLength()
	{
		T sum = 0.0f;
		int count = 0;

		for (int tri_ix = 0; tri_ix < triangles_.num_elements_; tri_ix++)
		{
			for (int d = 0; d < 3; d++)
			{
				if (tri_ix < edge_tri_ix_of_triangles_[tri_ix].v0_)
				{
					sum += tri_ops_.getEdgeLength(tri_ix, d);
					count++;
				}
			}
		}

		return sum /= (T)count;
	}
};
